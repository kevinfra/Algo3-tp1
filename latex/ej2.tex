
\section{Ejercicio 2: Problemas en el camino}
    % 1. Describir detalladamente el problema a resolver dando ejemplos del mismo y sus soluciones.
	\subsection{Descripción del problema}

	\begin{figure}[ht]
		\begin{center}
			\includegraphics[width=0.5\columnwidth]{imagenes/balanza.jpg}
			\caption{Equilibro}
		\end{center}
	\end{figure}

	Luego de cruzar el puente, el equipo se encuentra en una habitación amplia con una puerta, la cual está cerrada. En el medio de la habitación hay una balanza de dos platillos, la cual contiene sobre su platillo izquierdo una llave que abre la puerta de la habitación. Al retirar la llave, se cambia el equilibro de la balanza, lo cual hace que se cierre la entrada de la habitación. La llave no sirve para abrir la puerta y lo único que puede realizar el equipo es recompener el equilibro de la balanza utilizando un conjunto de pesas de potencia de 3 distintas. Es decir, sólo disponen de una sóla pesa de cada potencia de 3. Los datos de entrada y de salida para el problema son los siguientes: 

	~

	\textbf{Formato de entrada:} El único dato de entrada es un entero $P$ que representa el peso de la llave.

	\begin{tabular}{ll}
		\texttt{P}
	\end{tabular}

	~

	\textbf{Salida:} La salida consiste en dos enteros $S$ y $T$ que representan la cantidad de pesas que hay que colocar en el platillo izquierdo y el derecho respectivamente, seguidas de otra línea con los valores de las pesas que se deben colocar del platillo izquierdo ordenadas de menor a mayor y finalmente otra línea con los valores de las pesas del platillo derecho, también con el mismo orden.

	\begin{tabular}{ll}
		\texttt{S} & \texttt{T} \\
		\texttt{I1 ...} & \texttt{...IS} \\
		\texttt{D1 ...} & \texttt{...DT} \\
	\end{tabular}

	~

	Se tiene como restricción que el peso $P$ está en el siguiente rango: 1$<=$ $P$ $<=$ $10^{15}$. La complejidad temporal debe ser a lo sumo $\ord(\sqrt{P})$. 

    % 2. Explicar de forma clara, sencilla, estructurada y concisa, las ideas desarrolladas para la resolución del problema. Utilizar pseudocódigo y lenguaje coloquial (no código fuente). Justificar por qué el procedimiento resuelve efectivamente el problema.
    \subsection{Solución propuesta}

	La idea propuesta para la resolución del problema consiste en buscar cómo obtener una representación del número $p$. Si se consigue una representación del mismo se puede equilibrar la balanza. Primero nos abtraemos de las restricciones del problema y pensamos que cualquier número $a$ $\in$ \mathds{N} admite un desarrollo en base $d$, utilizando sólo símbolos comprendidos en el rango de 0 a $d-1$. Como se dispone de sólo pesas que son potencias de 3, se decide utilizar la base 3 para representar el número. Si el problema no tuviera la restricción de que sólo se dispone de una pesa de cada potencia de 3, la resolución sería trivial ya que sólo consiste en obtener el desarrollo en base 3 del número $p$ (que es un dato de entrada y que se asume que su desarrollo es en base 10) y poner tantas pesas de cada potencia de 3 (hasta 2 por potencia ya que en base 3, sólo se pueden utilizar los símbolos 0, 1 y 2) como indique el desarrollo, en el plato de la izquierda de la balanza para obtener el mismo peso $p$. Pero la restricción de que sólo se dispone de una sóla pesa de cada potencia de 3 hace que dicha solución no funcione. No obstante, teniendo en cuenta que en la balanza, las pesas que se colocan en el lado derecho 'restan' el peso colocado en el plato izquierdo se puede pensar en una solución en la cual cuando se tengan que utilizar dos pesas de la misma potencia, se puedan reemplazar por el uso de una pesa mayor colocada en el plato izquierdo (la cual se interpretaría como suma de dicha potencia de 3) y el uso de otra pesa colocada en el plato derecho (la cual se interpretaría como resta de dicha potencia de 3). Para lograr que la suma de dicha pesa menos la resta de la otra pesa, den como resultado el mismo valor que las dos pesas originales, se debe encontrar alguna relación entre las potencias de 3. La solución propuesta consiste en lo siguiente: 

	\newline

     \textbf{Caso 1:} El desarrollo en base 3 del número $p$ no contiene el símbolo 2.

    Este caso es trivial. Significa que a lo sumo se usa una vez cada potencia de 3 en el desarrollo del número. Por lo tanto, para obtener la solución al problema sólo bastar tomar las pesas correspondientes (las potencias de 3 que se utilizan en el desarrollo) y colocarlas en el plato izquierdo de la balanza para obtener el mismo peso original $p$ y equilibrarla.

	\newline

     \textbf{Caso 2:} El desarrollo en base 3 del número $p$ contiene al menos un símbolo 2.

    Este es el caso interesante ya que no se dispone de dos pesas de la misma potencia. Sin embargo, se pueden reemplazar dos pesas de la misma potencia de la siguiente manera:

    \newline

    \begin{center}

    	2.3^n = 3^{n+1} - 3^{n}

    	\newline

		2.3^n = 3.3^n - 3^n

		\newline

		2.3^n = (3 -1).3^n

		\newline

		2.3^n = 2.3^n

    \end{center}

	Es decir, se pueden reemplazar dos pesas de una potencia de 3 por la inmediata potencia de 3 superior menos una sóla pesa de las dos potencias de 3. Igualmente esto no siempre se puede realizar ya que puede darse el caso de que ya se estén usando dos pesas de la potencia de 3 inmediata superior como en el siguiente ejemplo:  


    \newline
    \begin{center}

    	$p$ = 1.3^2 + 2.3^1 + 2.3^0
    
    \end{center} 

    Entonces se debe encontrar una solución general que resuelva el problema antes mencionado. Se propone la siguiente solución:

    \newline
    \begin{center}

    \sum_{i=0}^{n}2.3^i = 3^{n+1} - 3^i

    \end{center}

    Se realiza la demostración de la anterior fórmula usando inducción en $n$: 

   \newline
    \textbf{Caso base:} $n = 0$

    \newline
    \begin{center}
    
    \sum_{i=0}^{0}2.3^i = 3^{1} - 3^0

    \newline

    2.3^0 = 3 - 1

	\newline

    2 = 2
    \end{center} 

    \newline
    \textbf{Paso inductivo:} Usamos como hipótesis inductiva (HI) que la fórmula vale para $n$ y queremos probar que vale para $n + 1$.

    \newline
    \begin{center}

    \sum_{i=0}^{n+1}2.3^i = 3^{n + 2} - 3^i

    \newline
    \sum_{i=0}^{n}2.3^i + 2.3^{n+1} = 3^{n + 2} - 3^i

    \newline
    Por HI:

    3^{n+1} - 3^i + 2.3^{n+1} = 3^{n + 2} - 3^i

   	\newline
	3.3^{n+1} - 3^i = 3^{n + 2} - 3^i

   	\newline
	3.3.3^{n} - 3^i = 3^{2}.3^{n} - 3^i

   	\newline
	9.3^{n} - 3^i = 9.3^{n} - 3^i

    \end{center} 

	\begin{flushright}

	\Box
	\end{flushright}

    Como conclusión se puede observar que cuando se tenga el caso de que no sea posible tomar una pesa de una potencia de 3 porque ya se usan dos pesas de dicha potencia y tampoco sea posible reemplazarla por la siguiente ya que también se usan dos pesas de dicha potencia (es decir, en el desarrollo del número hay varios símbolos 2 consecutivos) se debe buscar la primer potencia de 3 más grande de la cual no se tenga que utlizar dos pesas y reemplazar las pesas originales por la suma del valor de la potencia 3 de la pesa encontrada menos el valor de la potencia de 3 más chica de la cual se utilizan dos pesas. Esta fórmula se puede aplicar a cada uno de los símbolos en el desarrollo del número.


	\subsubsection{Implementación}\label{ej2_imp}

	Habiendo introducido la idea, se detalla el comportamiento del algoritmo para
	una entrada con $P$.

	Se presenta un pseudocódigo para tener de referencia al seguir la
	explicación detallada a continuación:

	\begin{codesnippet}
	\begin{verbatim}
	izquierda = verdadero
	divisiones = 0
	izquierdas = []
	derechas = []
	Mientras p != 0
	    cociente = p / 3
	    resto = p - (cociente *3)
	    Si resto es 0
	      Si no lo puse en izquierda al anterior
	        Agrego a izquierdas la pesa con valor (3 ^ divisiones)
	      izquierda = verdadero
	    Si resto es 1
	      Si anterior lo puse en izquierda
	        Agrego a izquierdas la pesa con valor (3 ^ divisiones)
	      Si no
	        Agrego a derechas la pesa con valor (3 ^ divisiones)
	    Si resto es 2
	      Si anterio lo puse en izquierda
	        Agrego a derechas la pesa con valor (3 ^ divisiones)
	      izquierda = falso
	    p = cociente
	    divisiones += 1
	Fin Mientras
	Si el último no lo puse en la izquierda
	   Agrego a izquierdas la pesa con valor (3 ^ divisiones)
	\end{verbatim}
	\end{codesnippet}

	\begin{enumerate}
		\item{
			La primera parte consiste en la inicialización de valores para el algoritmo. Se tiene una variable booleana que indica en qué platillo fue colocada la última pesa para cada iteración. Esta variable se inicializa en verdadera y es utilizada para saber en qué platillos hay que colocar las pesas que siguen. Esta variable es muy importante ya que determina en qué casos se van a reemplazar dos pesas de una potencia de 3, por otras pesas y cómo hacerlo. La variable divisiones es simplemente un índice que representa la cantidad de divisiones realizadas al número P. Por último se tienen dos listas inicializadas vacías, que van a almacenar las pesas que hay que colocar en los platillos izquierdo y derecho.
		}

		\item{
			El ciclo principal se ejecuta mientras P sea distinto de cero. En el cuerpo del ciclo se realiza la división del número P por 3 y se almacenan en dos variables distintas el cociente y el resto de dicha operación. Para el caso del valor del resto se tienen 3 posibilidades:
			\begin{enumerate}
				\item{
					EL resto es igual a 0: En este caso hay que preguntar si la anterior pesa fue colocada o no en el platillo derecho. Si fue colacada en el platillo derecho, se agrega a la lista de izquierdas la pesa que corresponde al valor (3$^{divisiones}$). La variable izquierda se actualiza con el valor verdadero, indicando que la última pesa fue colacada del lado izquierdo.
				}
				\item{
					El resto es igual a 1. En este caso tenemos dos posibilidades distintas:
					\begin{enumerate}
						\item{
							La anterior pesa fue colocada del lado izquierdo, por lo tanto esta pesa también tiene que colocarse del mismo lado. Se agrega entonces a la lista de izquierdas el valor (3$^{divisiones}$).
						}
						\item{
							La anterior pesa fue colocada del lado derecho, por lo tanto esta pesa también tiene que colocarse del mismo lado. Se agrega entonces a la lista de derechas el valor (3$^{divisiones}$).
						}
					\end{enumerate}
				\item{
					El resto es igual a 2: Sólo basta con fijarse si la anterior pesa fue colacada en el platillo izquierdo. De ser así, se debe agregar a derechas la pesa con el valor (3$^{divisiones}$).
				}
				}
				\end{enumerate}
			}
			\item{
			    Lo último que se realiza en el ciclo es actualizar el valor de P, el cual va a contener el valor del cociente calculado al principio. De esta manera el valor de P se irá decrementando en cada ciclo hasta llegar a cero. También se suma uno al índice de divisiones.
				Finalmente, se pregunta si la última pesa fue colocada en la lista de derechas. De ser así, se agrega a la lista de izquierdas la pesa con valor (3$^{divisiones}$).
			}
	\end{enumerate}

	\subsubsection{Demostración de correctitud}

	Habiendo visto cómo funciona el algoritmo desarrollado, se procede a
	justificar por qué devuelve una solución. Para esto se explicará el algoritmo en base a las justificaciones matemáticas realizadas en la solución propuesta.
	\subsubsection*{Correctitud de ciclo}

	Lo que se va a demostrar a continuación es que el ciclo principal termina y calcula la solución al problema.

	El ciclo se ejecuta mientras P sea distinto de cero. Es decir termina cuando P es 0 y esto ocurre ya que lo que se hace en el ciclo es dividir el número P por 3 y reemplazar P por el resultado (cociente) de esta división en cada iteración. Eventualmente el cociente va a ser cero, por los teoremas de división entera y de desarrollo en base $d$. Lo que se está haciendo es utilizar el algoritmo de división para obtener el desarrollo en base 3 del número $P$. Los restos en cada iteración son los que indican que símbolos hay que utilizar para la representación del número en esa base. En este caso no interesa obtener la representación del número en base 3, sino trabajar con los símbolos en su desarrollo (restos). El resto de la división sólo puede ser 0, 1 o 2 (por el teorema de la división entera).

	A continuación se analiza la parte fundamental del algoritmo que consiste en la identificación de qué pesas utilizar y en qué platillos colocarlas dependiendo del resto. Se tienen las siguientes posibilidades: 

	\begin{enumerate}
		\item{
			Resto == 0. En este caso, si la última pesa fue colocada del lado izquierdo no hay que realizar nada. Esto es porque el anterior dígito en el desarrollo era o bien otro cero o un 1. Por lo tanto no es necesario utilizar esta pesa para compensar una de un valor menor que no pudo ser utilizada porque se estaban usando dos (esto fue explicado en la solución propuesta). En cambio si la anterior pesa fue colocada del lado derecho es porque el anterior dígito en el desarrollo del número era un 2. En este caso, hay que utilizar esta pesa, por lo que se agrega a la lista de izquierdas el valor de la potencia de 3 correspondiente. Independientemente de si se utilizó esta pesa o no, la variable izquierda se actualiza con el valor verdadero, ya que el hecho de que no se use una pesa de una determinada potencia también se toma como que se 'usó'' la pesa de la izquierda. Esto es porque en el caso de que el siguiente dígito en el desarrollo sea un uno, se tiene que poder distinguir si el anterior fue un 0 o un 2, lo cual no se podría realizar si no se actualiza el valor de esta variable. En la explicación del caso del resto 1 se puede entender mejor esta conclusión. 
		}
		\item{
			Resto == 1. En este caso siempre hay que agregar una pesa. Si el valor de la variable izquierda es verdadero (esto es porque el anterior dígito fue un 0 o un 1) hay que agregar esta potencia de 3 a la lista de izquierda. En el caso contrario significa que el anterior dígito era un 2 y como se demostró en la solución propuesta hay que colocar esta pesa en el lado derecho, ya que si el anterior fue un 2 hay que tomar este dígito, lo que lo convertiría de un 1 a un 2, y por lo tanto hay que aplicar nuevamente la fórmula propuesta. Por lo tanto en este último caso se agrega la potencia de 3 correspodiente en la pesa derecha. El valor de la variable izquierda no es necesario actualizarlo ya que si se agrega a la lista de izquierdas hay que modificarlo por verdadero (lo cual ya ocurre porque se agrega solamente a izquierdas si es verdadero) y si se agrega a la lista de derechas hay que modificarlo por falso (lo cual ya ocurre porque se agrega solamente a derechas si es falso).
		}
		\item{
			Resto == 2. En este caso se usa también la idea planteada en la solución al problema. Se agrega a la lista de derechas la pesa con el valor de la potencia de 3 correspondiente solamente si la anterior fue colocada en el lado izquierdo (es decir el anterior dígito es un cero o un uno) ya que si el anterior era un 2 no hay que realizar nada (por lo visto en la demostración de la solución). Finalmente se actualiza el valor de izquierda y se pone en falso siempre, ya que es necesario para el siguiente dígito en el desarrollo, ya que como se vió si el siguiente es cero va a haber que tomar la siguiente pesa y si es un 1 va a haber que colocar la pesa en el lado derecho.	
		}
	\end{enumerate}

	Como el ciclo finaliza cuando P es igual a cero, se puede dar el caso de que el último dígito en el desarrollo del número en base 3 (el más significativo) sea un 2. Por lo tanto y sabiendo que no sigue ningún dígito más, lo que hay que hacer si se da este caso es tomar esta pesa por lo visto en la solución.

	En conclusión lo que hace el algoritmo es dividir iterativamente el número por 3, obteniendo de esta forma su desarrollo en base 3 y al mismo tiempo colocando las pesas correspondientes en base a los restos obtenidos (teorema de desarrollo en base $d$). No es necesario obtener primero la representación del número en la base y después aplicar la solución; se puede realizar mientras se obtiene, tomando decisiones en base al resto de la división en cada iteración. La idea propuesta garantiza que el algoritmo siempre va retornar una solución por lo visto en la sección de "Solución". Las decisiones que se toman con los restos son las inferidas por la solución propuesta: si el dígito es 0, no se toma esa pesa salvo que el anterior sea un 2. si el dígito es 1, si el anterior es 0 o 1 se toma esa pesa, sino se resta la pesa; finalmente si el dígito es 2, si anterior es 2 no se toma ninguna acción y si no se resta la pesa. Además el algoritmo de división garantiza que las pesas que se toman, van a estar ordenadas de menor a mayor cumpliendo con la restricción del problema.

    % 3. Deducir una cota de complejidad temporal del algoritmo propuesto y justificar por qué el algoritmo cumple la cota dada. Utilizar el modelo uniforme.
	\subsection{Complejidad teórica}

	Para calcular la complejidad teórica de la solución propuesta se hará
	referencia a la sección \ref{ej2_imp} donde se posée el pseudocódigo junto a
	su explicación.

	El algoritmo tiene una complejidad temporal de $\ord(log(n))$, por lo tanto es
	logarítmico y cumple con la restricción de complejidad del enunciado. Esto se justifica con el hecho de que el algoritmo posee un ciclo
	principal que se ejecuta mientras $P$ sea distinto de cero, es decir desde el número $P$ hasta el número 0. En cada iteracion el tamaño de $P$ se reduce a un tercio, ya que se divide por 3. Por lo tanto el ciclo se ejecuta la cantidad de símbolos necesarios para obtener el número $P$ en base 3. Si $P$ requiere de $n$ símbolos es que:

	\newline
	$d^{n-1} <= P < d^n$

	\newline
	es decir, $n -1 <= log_3(P) < n$, lo que implica que $[log_3(P)] = n - 1$ y por lo tanto $n = [log_3(P)] + 1$


	Dentro del ciclo sólo se hacen comparaciones que tienen un costo asociado de $\ord(1)$, una división, una multiplicación y una resta de enteros (costo $\ord(1)$), una asignación y una suma, y se agregan elementos a una lista (todas estas operaciones tambien en $\ord(1)$). Por lo tanto se concluye que la complejidad del ciclo es $\ord(log(n))$. Fuera del ciclo sólo se realizan incializaciones de variables $\ord(1)$ al principio del algoritmo y una comparación e inserción en una lista al final también en $\ord(1)$. Por álgebra de órdenes de funciones, la complejidad temporal resultante del algoritmo es $\ord(log(n))$. 

    % 4. Dar un código fuente claro que implemente la solución propuesta. Se deben incluir las partes relevantes del código como apéndice del informe impreso entregado.

    \subsection{Experimientacion}
         

	Se realizaron pruebas experimentales para verificar que el tiempo de
	ejecución del algoritmo cumpliera con la cota asintótica de $\ord(log(n))$,
	demostrada teóricamente. Se realizaron las siguientes pruebas:
        
        \begin{itemize}
            \item Pruebas con instancias con donde con una Genkidama se
				destruyen a todos los enemigos.
            \item Pruebas con instancias donde se requieren $N$ Genkidamas para
				eliminar a todos.
            \item Pruebas con instancias generadas aleatoriamente, para obtener una aproximación al comportamiento del algoritmo en el caso promedio.
            \item Pruebas fijando un $N$ y variando el $T$.
        \end{itemize}

        \subsubsection{Instancias particulares}

            Todas las instancias utilizadas para estas pruebas se generaron de manera aleatoria, pero restringiendo los resultados obtenidos para cumplir con determinadas características. A continuación se enumeran los criterios tenidos en cuenta para la generación de los escenarios de prueba.

            \begin{itemize}
                \item \textbf{Una Genkidama:} Para el caso donde una
					Genkidama mata a todos los enemigos, se generaron
					coordenadas dentro del rango $T$ de un enemigo en
					particular. Se denomina $T_1$ al tiempo transcurrido en dicho caso.

                \item \textbf{$N$ Genkidamas:} Para el caso donde hay que matar
					a cada enemigo con una Genkidama distinta, se generaron coordenadas a
					una distancia mayor a $T$ con respecto a las coordenadas $X$ e
					$Y$ de sus vecinos. Se denomina $T_2$ al tiempo para este
					escenario.

				\item \textbf{Coordenadas aleatorias:} Se generaron coordenadas
				$X$ e $Y$ al azar y luego se ordenaron para que cumplan con la
			descripción del problema. Se denomina $T_3$ al tiempo que toma en dicho caso.

				\item \textbf{$T$ con un $N$ fijo:} Para ver que $T$ no	afecta
					la complejidad del algoritmo, se fijo un número de enemigos
					($N = 10000$) y se hizo variar el valor de $T$. Se llamara $T_4$
					al tiempo transcurrido para estas instancias.
            \end{itemize}

		En cada experimento se graficaron los resultados para entradas de valor
		mayor o igual a 500 con el propósito de ignorar los valores pequeños sensibles al ruido
		del sistema en el que se realizaron las pruebas.


    \renewcommand\constante{5}

	\begin{figure}[H]
		\centering
		\caption{}
		\label{fig:exp2:part_tiempo_base}
		\begin{tikzpicture}
			\begin{axis}[
					title={},
					xlabel={Tamaño de entrada ($N$)},
					ylabel={Tiempo de ejecución (nanosegundos)},
					scaled x ticks=false,
					scaled y ticks=false,
					ymin=0,
					enlargelimits=0.05,
					width=0.5\textwidth,
					height=0.5\textwidth,
					legend pos=north west,
					legend cell align=left,
					xmin=1
				]

				\addplot[color=black] table[x index=0,y index=1 ]{../exp/genkidama_mejor_caso_output};
				\addplot[color=blue] table[x index=0,y index=1 ]{../exp/genkidama_peor_caso_output}; 
				\addplot[color=red] table[x index=0,y index=1 ]{../exp/genkidama_caso_intermedio_output};
				\addplot[color=green] table[x index=0,y expr={x*\constante}]{../exp/genkidama_caso_intermedio_output};
				\legend{$T_1$, $T_2$ , $T_3$, $c*N$ }
			\end{axis}
		\end{tikzpicture}
	\end{figure}
	En la Figura \ref{fig:exp2:part_tiempo_base} se puede ver :

	     \begin{itemize} 
            \item El caso $T_3$ es el que peor constante tiene, ya que cae más
				seguido al condicional más costoso del algoritmo que es el que
				en caso de no estar cubierto por una Genkidama anterior pero si
				tener un sucesor que lo alcance, debe verificar que este también
				llegue a cubrir enemigos pendientes.
            \item El caso $T_2$ tiene una constante mayor que $T_1$ ya que al
				siempre tener que agregar un genkidama, para llegar a esa
				decisión antes debe verifcar que el anterior y el siguiente no lo cubren.
             \item Se puede ver que el caso $T_1$ tiene una constante más
				 pequeña que el resto, esto se debe a que como solo basta un
				 genkidama para matar a todos los enemigos, después de tirar ese
				 genkidama los siguiente puntos únicamente verifican que
				 efectivamente los cubre una Genkidama anterior.
            \item Los tres escenarios son acotados por $c*N$ con $c = 11.5$ lo
				cual demuestra que están acotados por una función lineal.
        \end{itemize}

	\begin{figure}[H]
		\centering
		\caption{}
		\label{fig:exp2:part_tiempo_sobre_n}
		\begin{tikzpicture}
			\begin{axis}[
					title={},
					xlabel={Tamaño de entrada ($N$)},
					ylabel={Tiempo de ejecución (nanosegundos)},
					scaled x ticks=false,
					scaled y ticks=false,
					ymin=0,
					enlargelimits=0.05,
					width=0.5\textwidth,
					height=0.5\textwidth,
					legend pos=north east,
					legend cell align=left,
					xmin=1
				]

				\addplot[color=red] table[x index=0,y expr={\thisrowno{1} / x} ]{../exp/genkidama_caso_intermedio_output};
				\addplot[color=black] table[x index=0,y expr={\thisrowno{1} / x} ]{../exp/genkidama_mejor_caso_output};
				\addplot[color=blue] table[x index=0,y expr={\thisrowno{1} / x} ]{../exp/genkidama_peor_caso_output}; 
				\addplot[color=green] table[x index=0, y expr={\constante}]{../exp/genkidama_caso_intermedio_output};
				\legend{$\frac{T_1}{N}$, $\frac{T_2}{N}$, $\frac{T_3}{N}$ , $c$}
			\end{axis}
		\end{tikzpicture}
	\end{figure}

	En la Figura \ref{fig:exp2:part_tiempo_sobre_n} se ve que al dividir los
	resultados de los experimentos anteriores por $N$, estos convergen a una
	constante que puede acotarse por el mismo $c$ de la Figura
	\ref{fig:exp2:part_tiempo_base}.


	\begin{figure}[H]
		\centering
		\caption{}
		\label{fig:exp2:part_tiempo_base_var_T}
		\begin{tikzpicture}
			\begin{axis}[
					title={},
					xlabel={Tamaño de entrada ($T$)},
					ylabel={Tiempo de ejecución (nanosegundos)},
					scaled x ticks=false,
					scaled y ticks=false,
					ymin=18000,
					ymax=28000,
					enlargelimits=0.05,
					width=0.5\textwidth,
					height=0.5\textwidth,
					legend pos=south east,
					legend cell align=left,
					xmin=1
				]
				\addplot[color=black] table[x index=0,y index=1 ]{../exp/genkidama_variar_T_output};
				\legend{$T_4$}
			\end{axis}
		\end{tikzpicture}
	\end{figure}

	En la Figura \ref{fig:exp2:part_tiempo_base_var_T} se observa cómo $T_4$
	converge a una constanste, corroborando así que su valor no afecta la
	complejidad temporal del algoritmo.

	 El análisis expuesto de los datos recopilados presenta evidencia empírica
	 sobre la cota de complejidad demostrada teóricamente. Además se logra ver
	 que la complejidad depende estrictamente de la cantidad de enemigos que
	 hay que eliminar y no del tamaño de $T$ .
