\section{Ejercicio 1}
    % 1. Describir detalladamente el problema a resolver dando ejemplos del mismo y sus soluciones.
    \subsection{Descripción del problema}
		\begin{figure}[ht]
			\begin{center}
				\includegraphics[width=0.5\columnwidth]{imagenes/expedicionistas.jpg}
				\caption{Indiana Jones junto a un Canibal del grupo de exploración}
			\end{center}
		\end{figure}
        Indiana Jones debe seguir un mapa que posiblemente lo lleve a encontrar la solución a P=NP. Para esto, lleva a un grupo de arquéologos compuesto por $A$ personas y le pide ayuda a un grupo de gente local de tamaño $C$ para poder llegar hasta su destino sin grandes problemas. Sin embargo, durante el camino se encuentran con un puente en mal estado en el que no podrán pasar más de dos personas a la vez. Sumado a eso, hay solo una linterna para todo el equipo, por lo que en cada cruce alguien debe volver con la linterna. Como si el problema del puente fuera poco, el grupo local es conocido por su canibalismo, así que no pueden quedar más caníbales que arqueólogos de alguno de los lados del puente.

        La resolución del problema consiste en elaborar un programa que recibe como entrada el valor de $A$ y $C$, y luego las velocidades de cada arqueólogo ($a_0, ... , a_A$) y la de cada canibal ($c_0, ... , c_C$) y devuelve la velocidad mínima con la que se puede cruzar el puente.

        Por ejemplo, si el programa recibe lo siguiente como entrada: \newline
        \texttt{2} \texttt{1} \newline
        \texttt{1} \texttt{2} \newline
        \texttt{1}

        La salida correcta sería: \newline
        \texttt{4}

    % 2. Explicar de forma clara, sencilla, estructurada y concisa, las ideas desarrolladas para la resolución del problema. Utilizar pseudocódigo y lenguaje coloquial (no código fuente). Justificar por qué el procedimiento resuelve efectivamente el problema.
    \subsection{Solución propuesta}
        La solución de este problema fue lograda considerando todos las formas de cruzar el puente suponiendo que de esa forma se pueda llegar a un final válido. Dado que el fin es cruzar el puente de la forma màs rápida, dejamos de lado la velocidad de quién va a cruzar el puente y nos enfocamos en a qué grupo pertenece. Siguiendo esta idea, siempre cruzarán los más rápidos de los que tengan la posibilidad de cruzar. Solamente van a tener esta chance quienes estén del lado que está en la linterna y que cruzar el puente no lleve a un \emph{estado inválido}. Un estado válido es aquél en el que no se estuvo anteriormente (es decir, que sea una situación que no haya ocurrido con anterioridad) y que no deje a más caníbales que arqueólogos de alguno de los dos lados. Si bien lo mejor es que crucen siempre los más rápidos, esto no siempre será posible. Es por esto, que los que crucen el puente serán los más rápidos de todas las combinaciones posibles entre los dos grupos siendo un cruce de 1 o 2 personas. Luego, los posibles cruces serán 2 personas del mismo grupo, 1 de un grupo y 1 de otro, o 1 sola de alguno de los dos grupos. Aquí es donde entra la importancia del estado inválido. La forma de corroborar que el movimiento lleve a un estádo válido es observando la cantidad de personas pertenecientes a cada uno de los grupos en cada lado del puente, sin importar su velocidad.

        La razón de esto es que da igual si los que están en algún lado del puente son tienen velocidad $a_1$ o $a_2$ ya que simplemente sería una permutación de éstos. A pesar de que esto puede impactar en el tiempo total del cruce del puente, el objetivo de probar con todos los caminos y obtener todos las \emph{soluciones válidas} hace que luego no sea importante quién está de cada lado.

        Para que una solución al problema sea válida, el tiempo que tome cruzar el puente debe ser mayor o igual a la suma de las velocidades de los todos los exploradores (caníbales y arqueólogos) y además en ninǵún momento del recorrido deben haber estados inválidos. Además, se pide que la solución final sea el menor tiempo posible que tome cruzar el puente. Este mismo será el mínimo entre todas las soluciones válidas.

        Teniendo en cuenta lo planteado en este informe sobre el problema, podemos marcar que el algoritmo realizado, fue construido en base a la técnica de \emph{backtracking} que al igual que en este caso, consiste en probar todas las posibilidades descartando la mayor cantidad de soluciones incorrectas posibles al mismo tiempo y dejando como resultado una lista con las soluciones válidas. Así, se prueban todos los caminos posibles para cruzar el puente y al final se obtiene una lista con todas los tiempos que puede tomar cruzar el puente.

        Los casos base de la recursión son triviales, ya que resultan del cruce del puente de 1 o 2 exploradores, sin importar su grupo, y el tiempo que toma eso es la velocidad del más lento. Aquí solo pueden ocurrir casos inválidos cuando habiendo 2 exploradores, se intente realizar el cruce de solo uno de ellos. En cualquier otro caso, el cruce será de un solo cambio de estado y en ningún momento pueden haber más exploradores de algúno de los grupos.

        Para el caso recursivo, se chequeará antes de entrar en la recursión que el estado al que se va a cambiar sea uno válido. Si no lo es, cambia la cantidad de exploradores que vayan a cruzar. Si siguen obteniéndose estados inválidos, entonces no quedarán casos para probar y simplemente terminará la búsqueda en esa rama de estados sin haber encontrado una solución válida.

        \subsubsection{Detalles implementativos}
            El algoritmo fue implementado en lenguaje C++. Para almacenar la solución, se recurre a la clase \texttt{vector}, proporcionada por la librería estándar del lenguaje.

            Para manejar los estados en el árbol de ejecución, se van almacenando los nuevos estados en un vector de \texttt{Estados} antes de entrar en una recursión y se quita al retornar de la misma. Esto es para que en la misma altura del arbol haya la misma cantidad de estados y para que no haya estados inválidos de una rama de desiciones en otra en la que se tomaron otros caminos.

            Un \texttt{Estado} es una clase la cual consiste de 4 \texttt{Int}, 2 para la cantidad de arqueólogos y 2 para la cantidad de caníbales de cada uno de los lados en ese momento, y de un \texttt{Bool} para indicar si la linterna se encuentra a la derecha o no.

            Llamamos \emph{árbol de ejecución} al árbol que se va generando de acuerdo a las desiciones tomadas en cuanto a qué explorador cruzará el puente.

        \begin{codesnippet}
        \begin{verbatim}
si estadoActual tiene linterna a la derecha
  lado de origen  = lado derecho
  lado de destino = lado izquierdo
si no
  lado de origen  = lado izquierdo
  lado de destino = lado derecho
linternaEnDeracha = !linternaEnDerecha

ordenarVelocudades canibalesEnOrigen
ordenarVelocudades canibalesEnDestino
ordenarVelocudades arqueologosEnOrigen
ordenarVelocudades arqeuologosEnDestino

para #CanibalesQueCruzan entre 0 y minimo(2, #canibales del lado de origen):
    para #ArqueologosQueCruzan entre 0 y (2 - #CanibalesQueCruzan):
        si esEstadoValido(#CanibalesEnOrigen - #canibalesQueCruzan,
                          #ArqueologosEnOrigen - #arqueologosQueCruzan,
                          #CanibalesEnDestino + #CanibalesQueCruzan,
                          #ArqueologosEnDestino + #ArqueologosQueCruzan,
                          linternaEnDerecha, estadosAnteriores):

            canibalesQueCruzan = canibalesEnOrigen[0 hasta #CanibalesQueCruzan]
            agregar canibalesQueCruzan a CanibalesEnDestino
            eliminar canibalesQueCruzan de CanibalesEnOrigen

            arqueologosQueCruzan = arqueologosEnOrigen[0 hasta #ArqeueologosQueCruzan]
            agregar arqueologosQueCruzan a ArqueologosEnDestino
            eliminar arqueologosQueCruzan de ArqueologosEnOrigen

            nuevoEstado = (tamaño(ArqueologosEnOrigen),
                          tamaño(ArqueologosEnDestino),
                          tamaño(CanibalesEnOrigen),
                          tamaño(CanibalesEnDestino),
                          linternaEnDerecha)

            nuevoTiempo = tiempoActual + max(si mandarArqueologos > 0
                                               entonces maximo(arqueologosMasRapidos)
                                               sino 0,
                                             si mandarCanibales > 0
                                               entonces maximo(canibalesMasRapidos)
                                               sino 0)

            agregar nuevoEstado a EstadosAnteriores
            recursiónCruzarPuente(estadosAnteriores, nuevoTiempo, soluciones)
            eliminar nuevoEstado de EstadosAnteriores
        fin si
    fin para
fin para
        \end{verbatim}
        \end{codesnippet}

            Esta es una porción del algoritmo completo, en la cual se muestra cómo funciona la parte recursiva del mismo. La variable \emph{soluciones} no se modifica en esta parte ya que es simplemente agregar el tiempoActual a la lista, siendo tiempoActual el contador de tiempo que toma hasta ese estado cruzar el puente. La idea de agregar nuevoEstado a EstadosAnterirores consiste en poder eliminar los caminos que lleven a una situación que ya se haya estado con anterioridad (por ejemplo, que cruce un canibal y luego vuelva). Además, al quitarla luego de la recursión hace que para cada altura del árbol de ejecución tengamos la misma cantidad de estados y que éstos sean todos distintos. La razón por la cual serán distintos proviene de que cada estado se arma basándose en la cantidad de arqueólogos y caníbales que hay de cada lado y de qué lado está la linterna. Entonces si cada vez que haya que cruzar el puente se elige una cantidad distinta de exploradores, cada nuevo estado tendrá como máximo 5 formas distintas (que cruce un solo canibal, un solo arqueólogo, dos canibales, dos arqueólogos o un arqueólogo y un canibal).

            La otra parte importante del algoritmo consiste en chequear si lograron cruzar todos los exploradores, que en tal caso como se menciona en el párrafo anterior, se agrega el tiempo que tomó cruzar el puente. Luego, se regresa hacia arriba en un nivel en el árbol de ejecución y se continúa probando las otras posibilidades de caminos.



    % 3. Deducir una cota de complejidad temporal del algoritmo propuesto y justificar por qué el algoritmo cumple la cota dada. Utilizar el modelo uniforme.
    \subsection{Complejidad teórica}
         
      Durante la ejecución del algoritmo se utiliza una matriz con $\lceil \log_2(N) \rceil$ filas y $N$ columnas. En primer lugar, se inicializa esta matriz en \texttt{2}, lo cual tiene un costo del orden de $N \times \log(N)$. Para generar las peleas se recorre esta matriz; se tiene un ciclo que recorre las filas, y dentro del mismo, dos ciclos anidados que se encargan de recorrer las columnas. Los límites de estos últimos dos ciclos varían según la fila; en la fila $i$-ésima, el ciclo externo itera hasta $N$ con incrementos de tamaño $2^i$ ($\frac{N}{2^i}$ iteraciones), mientras que el ciclo interno itera hasta $2^i$ con saltos de a $1$ ($2^i$ iteraciones).

      Por lo tanto, la cantidad de veces que se ejecuta el ciclo interno, sumando sobre todas las filas de la matriz, es

      \[\sum_{i = 0}^{\log(N)} \sum_{j = 0}^{\frac{N}{2^i}} 2^i = \sum_{i = 0}^{\log(N)} \frac{N}{2^i} 2^i = \sum_{i = 0}^{log(N)} N = N \times \log(N)\]

      Como dentro de este último ciclo solo se modifica el valor de una posición de la matriz, con un costo $\ord(1)$, se puede concluir que la complejidad total del algoritmo es $\ord(N \times \log(N))$. 


    % 4. Dar un código fuente claro que implemente la solución propuesta. Se deben incluir las partes relevantes del código como apéndice del informe impreso entregado.

    % 5. Realizar una experimentación computacional para medir la performance del programa implementado. Usar un conjunto de casos de test en función de los parámetros de entrada, con instancias aleatorias e instancias particulares (de peor/mejor caso en tiempo de ejecución, por ejemplo). Presentar en forma gráfica una comparación entre los tiempos medidos y la complejidad teórica calculada y extraer conclusiones.
    \subsection{Experimentación}

	A la hora de medir el rendimiento del algoritmo y confirmar la complejidad
	teórica se tuvieron que considerar varios aspectos tales que los
	resultados de la experimentación reflejaran lo mejor posible su
	comportamiento.

	Dado que el problema consiste en una única entrada, los casos de prueba
	posibles se reducen al conjunto de los números enteros positivos. Como la
	complejidad temporal del algoritmo es $\theta(Nlog(N))$, no hay un peor
	y mejor escenario, por lo tanto no es necesario establecer condiciones sobre
	la entrada.

	El experimento consiste en la medición de los tiempos de ejecución para
	entradas cada vez más grandes. A continuación se describen las condiciones aplicadas
	para el mismo:

	\begin{itemize}
		\item{Como entrada se utilizó $N = k$ con $200 < k < 100000$}
		\item{Por cada $N$, se repitió 40 veces la medición y se calculó un
			promedio.}
	\end{itemize}

	De estos puntos, cabe destacar la elección de comenzar con $N = 200$. Esta
	decisión surge del hecho de que en valores pequeños las mediciones de tiempo
	son más sensibles a perturbaciones del sistema en el que están corriendo.
	Por lo tanto, en base a las pruebas realizadas, se optó por ignorar los
	primeros valores dado que no aportaban información pertinente al experimento.

	Los resultados obtenidos fueron los siguientes. En los gráficos, $T$ representa el
    tiempo de ejecución obtenido en las mediciones.

	\newcommand\constante{3}
	\begin{figure}[H]
		\centering
		\caption{}
		\label{fig:exp1:tiempo_base}
		\begin{tikzpicture}
			\begin{axis}[
					title={},
					xlabel={Tamaño de entrada ($N$)},
					ylabel={Tiempo de ejecución (nanosegundos)},
					scaled x ticks=false,
					scaled y ticks=false,
					enlargelimits=0.05,
					width=0.5\textwidth,
					height=0.5\textwidth,
					legend pos=south east,
					legend cell align=left,
					xmin=1
				]
				\addplot[color=black] table[x index=0,y index=1]{../exp/kaioKenOutput};
				\addplot[color=red] table[x index=0, y expr={x*ln(x)*\constante}]{../exp/kaioKenOutput};
				\legend{$T$, $c*N*log(N)$}
			\end{axis}
		\end{tikzpicture}
	\end{figure}

	En la Figura \ref{fig:exp1:tiempo_base} se puede observar como la curva generada por el
	tiempo de ejecución puede ser acotada para un $c$ fijo por una función
	$c*N*log(N)$. Para ratificar esta observación se procede dividiendo cada $T$
	por su respectivo $N$ con la intención de generar una curva de forma
	logarítmica.

	\begin{figure}[H]
		\centering
		\caption{}
		\label{fig:tiempo_sobre_n}
		\begin{tikzpicture}
			\begin{axis}[
					title={},
					xlabel={Tamaño de entrada ($N$)},
					ylabel={Tiempo de ejecución (nanosegundos)},
					scaled x ticks=false,
					scaled y ticks=false,
					ymax=100,
					enlargelimits=0.05,
					width=0.5\textwidth,
					height=0.5\textwidth,
					legend pos=south east,
					legend cell align=left,
					xmin=1
				]
				\addplot[color=black] table[x index=0,y index=2]{../exp/kaioKenOutput};
				\addplot[color=red] table[x index=0, y expr={ln(x)*\constante}]{../exp/kaioKenOutput};
				\legend{$\frac{T}{N}$, $c*log(N)$}
			\end{axis}
		\end{tikzpicture}
	\end{figure}

	Con la Figura \ref{fig:tiempo_sobre_n} se corrobora lo previsto, ya que
	efectivamente se puede apreciar cómo con la misma constante $c$ se puede
	acotar por una función $c*log(N)$.

	\begin{figure}[H]
		\centering
		\caption{}
		\label{fig:tiempo_sobre_n_log_n}
		\begin{tikzpicture}
			\begin{axis}[
					title={},
					xlabel={Tamaño de entrada ($N$)},
					ylabel={Tiempo de ejecución (nanosegundos)},
					scaled x ticks=false,
					scaled y ticks=false,
					ymin=0,
					ymax=5,
					enlargelimits=0.05,
					width=0.5\textwidth,
					height=0.5\textwidth,
					legend pos=south east,
					legend cell align=left,
					xmin=1
				]
				\addplot[color=black] table[x index=0,y index=3]{../exp/kaioKenOutput};
				\addplot[color=red] table[x index=0, y expr={\constante}]{../exp/kaioKenOutput};
				\legend{$\frac{T}{N*log(N)}$, $c$}
			\end{axis}
		\end{tikzpicture}
	\end{figure}

	Finalmente, en la Figura \ref{fig:tiempo_sobre_n_log_n} se tiene que
	$\frac{T}{N*log(N)}$ converge a una constante que puede ser acotada por $c =
	\constante$. Este $c$ es el mismo que es utilizado en las figuras
	anteriores.

	Es así como se llega a la conclusión de que efectivamente la complejidad
	temporal de la solución desarrollada coincide con la complejidad teórica estipulada.

	Para reproducir los datos utilizados basta con ejecutar \texttt{KaioKenSolver
	-p}.
